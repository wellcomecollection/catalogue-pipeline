package weco.catalogue.internal_model.index

import com.sksamuel.elastic4s.ElasticDsl._
import diffson._
import diffson.lcs._
import diffson.circe._
import diffson.jsonpatch.lcsdiff._
import io.circe.{ACursor, Json}
import io.circe.parser._
import org.scalatest.{Assertion, EitherValues, OptionValues}
import org.scalatest.funspec.AnyFunSpec
import org.scalatest.matchers.should.Matchers
import weco.elasticsearch.IndexConfig
import weco.fixtures.LocalResources
import weco.json.utils.JsonAssertions

/**
  * These tests are to allow us to confirm that the JSON
  * from the Scala index config matches the work we do
  * in the rank app for search.
  *
  * Once index config has been finalised in rank, and the
  * resultant JSON copied to the files in `resources`,
  * this test will confirm that it is equivalent to the config
  * created using the elastic4s DSL.
  */
class SearchIndexConfigJsonTest
    extends AnyFunSpec
    with Matchers
    with EitherValues
    with OptionValues
    with LocalResources
    with JsonAssertions
    with IndexFixtures {
  def assertIndexConfigIsEquivalent(
    jsonFile: String,
    indexConfig: IndexConfig
  ): Assertion = {
    val fileJson =
      parse(readResource(jsonFile)).right.value.hcursor
    val fileMapping: Json = fileJson.downField("mappings").focus.value
    val fileSettings: Json = fileJson.downField("settings").focus.value
    /*
     * We PUT the mapping and settings generated by elastic4s into a local index
     * before comparing them to the rank mappings. This is because Elasticsearch
     * might restructure them slightly from the JSON it receives. Specifically,
     * we've seen that field names with dots ("a.b.c") get expanded into nested objects
     * ({ a: { b: { c: ... } } })
     */
    withLocalElasticsearchIndex(config = indexConfig) { index =>
      val indexMapping =
        getJsonForIndex(
          index.name,
          "mappings",
          elasticClient
            .execute {
              getMapping(index.name)
            }
            .await
            .body
            .value
        ).focus.value

      val indexSettings = getAnalysisSettingsOnly(
        responseBody = elasticClient
          .execute {
            getSettings(index.name)
          }
          .await
          .body
          .value,
        indexName = index.name
      )

      implicit val lcs: Patience[Json] = new Patience[Json]

      println("Mapping diff:")
      println(diff(fileMapping, indexMapping))

      println("Settings diff:")
      println(diff(fileMapping, indexMapping))

      fileMapping shouldBe indexMapping
      fileSettings shouldBe indexSettings
    }
  }

  it("generates the correct works index config") {
    assertIndexConfigIsEquivalent(
      "WorksIndexConfig.json",
      WorksIndexConfig.indexed
    )
  }

  it("generates the correct images index config") {
    assertIndexConfigIsEquivalent(
      "ImagesIndexConfig.json",
      ImagesIndexConfig.indexed
    )
  }

  private def getAnalysisSettingsOnly(
    responseBody: String,
    indexName: String
  ): Json = {
    val indexJson = getJsonForIndex(indexName, "settings", responseBody)
    val filteredJson = indexJson
      .downField("index")
      .withFocus(_.mapObject(_.filter {
        // We're only interested in looking at the analysis part of the settings
        case ("analysis", _) => true
        case _               => false
      }))
      .up
    filteredJson.focus.value
  }

  private def getJsonForIndex(
    index: String,
    path: String,
    json: String
  ): ACursor =
    parse(json).right.value.hcursor
      .downField(index)
      .downField(path)
}
